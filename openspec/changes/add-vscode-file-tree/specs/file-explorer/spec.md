## 新增需求

### 需求:按需目录读取

系统必须实现按需加载目录内容的机制,仅在用户展开目录节点时读取其子项,避免预加载全量目录树。

#### 场景:展开目录节点

- **当** 用户点击目录节点的展开图标
- **那么** 系统应异步读取该目录的直接子项(文件和子目录)
- **并且** 显示加载状态指示器
- **并且** 将结果缓存以供后续访问

#### 场景:已缓存目录

- **当** 用户展开已读取过的目录
- **那么** 系统应直接从缓存返回结果
- **并且** 不触发文件系统 IO 操作
- **并且** 响应时间应小于 50ms

#### 场景:强制刷新

- **当** 用户右键菜单选择"刷新"
- **那么** 系统应清除该目录的缓存
- **并且** 重新从文件系统读取
- **并且** 更新 UI 显示

### 需求:虚拟列表渲染

系统必须使用虚拟滚动技术,仅渲染可视区域内的文件树节点,以支持大目录的流畅交互。

#### 场景:大目录渲染

- **当** 文件树包含超过 1000 个节点
- **那么** 系统应仅渲染可视区域内的节点
- **并且** DOM 节点数量不超过可视区域容纳数量的 2 倍
- **并且** 滚动帧率应保持在 55 FPS 以上

#### 场景:滚动交互

- **当** 用户滚动文件树
- **那么** 系统应动态更新可视区域节点
- **并且** 保持滚动位置的准确性
- **并且** 无明显卡顿或跳跃

### 需求:实时文件监听

系统必须监听文件系统变化,并自动更新文件树 UI,无需用户手动刷新。

#### 场景:文件创建

- **当** 工作空间内创建新文件
- **那么** 系统应在 200ms 内检测到变化
- **并且** 清除受影响目录的缓存
- **并且** 通知前端更新 UI
- **并且** 在文件树中显示新文件

#### 场景:文件删除

- **当** 工作空间内删除文件
- **那么** 系统应检测到变化并更新缓存
- **并且** 从文件树中移除对应节点
- **并且** 不影响其他目录的显示

#### 场景:批量文件变化

- **当** 短时间内发生多个文件变化(如 Git 切换分支)
- **那么** 系统应防抖处理,合并 50ms 内的变化事件
- **并且** 仅触发一次 UI 更新
- **并且** 避免频繁闪烁

### 需求:文件树交互

系统必须提供完整的文件树交互功能,包括展开/折叠、右键菜单、文件操作等。

#### 场景:展开折叠

- **当** 用户点击目录节点
- **那么** 系统应切换该节点的展开/折叠状态
- **并且** 更新展开图标(▶ 或 ▼)
- **并且** 显示或隐藏子节点

#### 场景:文件创建

- **当** 用户在目录上右键选择"新建文件"
- **那么** 系统应弹出输入框
- **并且** 验证文件名合法性
- **并且** 创建文件后刷新父目录
- **并且** 选中新创建的文件

#### 场景:文件重命名

- **当** 用户在文件上右键选择"重命名"
- **那么** 系统应弹出输入框,预填充当前文件名
- **并且** 验证新文件名不冲突
- **并且** 执行重命名操作
- **并且** 清除相关缓存并更新 UI

#### 场景:文件删除

- **当** 用户在文件上右键选择"删除"
- **那么** 系统应弹出确认对话框
- **并且** 用户确认后执行删除
- **并且** 从文件树中移除节点
- **并且** 如果是目录,递归删除所有子项

### 需求:文件搜索

系统必须提供文件名搜索功能,支持快速定位目标文件。

#### 场景:按文件名搜索

- **当** 用户在搜索框输入关键词
- **那么** 系统应遍历工作空间目录
- **并且** 返回文件名包含关键词的所有文件
- **并且** 支持大小写不敏感匹配
- **并且** 显示完整路径供用户选择

#### 场景:搜索结果选择

- **当** 用户点击搜索结果中的文件
- **那么** 系统应在文件树中展开对应路径
- **并且** 高亮选中目标文件
- **并且** 滚动到可视区域

### 需求:路径导航

系统必须提供面包屑导航,显示当前目录路径并支持快速跳转。

#### 场景:显示当前路径

- **当** 用户浏览文件树
- **那么** 系统应在顶部显示当前工作目录的完整路径
- **并且** 路径以面包屑形式展示(可点击)
- **并且** 超长路径应适当省略

#### 场景:路径跳转

- **当** 用户点击面包屑中的某一层级
- **那么** 系统应跳转到该目录
- **并且** 在文件树中展开对应节点
- **并且** 滚动到可视区域

### 需求:性能优化

系统必须实现多层缓存和优化策略,确保大目录的流畅交互。

#### 场景:双层缓存

- **当** 系统读取目录内容
- **那么** Rust 层应将结果缓存 5 分钟
- **并且** 前端层也缓存结果
- **并且** 两层缓存独立失效和更新

#### 场景:大目录性能

- **当** 工作空间包含 10 万+文件
- **那么** 初始加载时间应小于 100ms
- **并且** 展开单个目录应小于 80ms
- **并且** 内存占用应小于 20MB
- **并且** 滚动帧率应保持 55-60 FPS

#### 场景:IPC 优化

- **当** 前端请求多个目录内容
- **那么** 系统应优先检查本地缓存
- **并且** 减少不必要的 IPC 调用
- **并且** 批量请求时合并通信

### 需求:跨平台支持

系统必须在 Windows、macOS、Linux 平台上正常工作,处理平台差异。

#### 场景:路径分隔符

- **当** 系统处理文件路径
- **那么** Rust 层应使用 std::path::Path 自动适配平台
- **并且** 前端应使用 path-browserify 处理路径
- **并且** 统一使用正斜杠(/)作为标准分隔符

#### 场景:隐藏文件

- **当** 系统读取目录内容
- **那么** Windows 应检查文件属性判断隐藏
- **并且** Unix 系统应检查文件名是否以点(.)开头
- **并且** 提供显示/隐藏切换选项

#### 场景:文件权限

- **当** 用户访问受保护的系统目录
- **那么** 系统应捕获权限错误
- **并且** 显示友好的错误提示
- **并且** 不中断整体文件树的显示

### 需求:错误处理

系统必须优雅处理各种错误情况,提供清晰的反馈。

#### 场景:目录读取失败

- **当** 文件系统 IO 失败(权限不足、目录不存在等)
- **那么** 系统应返回错误信息
- **并且** 在 UI 上显示错误状态
- **并且** 允许用户重试操作

#### 场景:文件操作失败

- **当** 创建/重命名/删除操作失败
- **那么** 系统应弹出错误提示
- **并且** 说明失败原因(如文件名非法、权限不足)
- **并且** 保持 UI 状态一致,不留下半完成的操作

#### 场景:文件监听失败

- **当** 文件监听初始化失败
- **那么** 系统应记录错误日志
- **并且** 提示用户需要手动刷新
- **并且** 文件树其他功能仍正常工作
