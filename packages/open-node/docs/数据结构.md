# Code RAG Schema 设计

> 为「多仓库 Code RAG + 代码地图」量身定制的 Schema 设计方案
> 设计目标：**检索准、过滤快、与图依赖系统解耦、Node.js 易实现**

---

## 数据模型设计

### 1. 设计目标

#### 1.1 核心能力

1. **跨仓库定位符号**
2. **表达结构层级（Repo → File → Symbol）**
3. **表达关系（import / call / depend）**
4. **支持 RAG 高效检索**
5. **支持增量更新（Git diff）**

#### 1.2 明确不追求

- 100% 准确的 JS 动态调用（不现实）
- 完整运行时调用栈

---

### 2. 总体数据模型（分 5 层）

```text
Workspace
 ├─ Repository-Master
 │   ├─ File
 │   │   ├─ Symbol
 │   │   └─ Symbol
 │   └─ File
 └─ Cross-Repo Relations
```

---

### 3. 核心实体定义

#### 3.1 Workspace（多仓库空间）

```ts
interface Workspace {
  id: string; // workspace_id
  name: string;
  description?: string;
}
```

说明：

- 一个 Workspace = 一套 RAG 知识域
- 多仓库统一在一个 workspace 下索引

#### 3.2 Repository（仓库级）

```ts
interface Repository {
  id: string; // repo_id
  workspaceId: string;

  name: string; // auth-service
  url: string; // git url
  defaultBranch: string;

  languageStats: {
    typescript?: number;
    javascript?: number;
  };

  lastIndexedCommit: string;
  indexedAt: number;
}
```

设计要点：

- **commit hash 是增量更新的关键**
- 不把文件直接挂在 workspace 下

#### 3.3 File（文件级）

```ts
interface File {
  id: string; // file_id
  repoId: string;

  path: string; // src/token.ts
  language: string; // typescript
  size: number;

  checksum: string; // 用于 diff
  lastModifiedCommit: string;
}
```

设计要点：

- `path + repoId` 唯一
- checksum 用于判断是否重建 symbol

#### 3.4 Symbol（核心实体）

> **这是代码地图的"原子单位"**

```ts
interface Symbol {
  id: string; // symbol_id（全局唯一）
  repoId: string;
  fileId: string;

  name: string; // verifyToken
  qualifiedName: string; // auth.verifyToken
  kind: 'function' | 'class' | 'method' | 'interface' | 'type';

  visibility: 'public' | 'private' | 'protected';
  exported: boolean;

  location: {
    startLine: number;
    endLine: number;
  };

  signature?: string; // (token: string) => User
  docComment?: string;

  codeChunk: string; // RAG chunk
}
```

**重要设计点**：

- **Symbol ≠ 文件**
- RAG 的最小索引单元是 **Symbol**
- 每个 symbol 可以独立 embedding

#### 3.5 Relation（关系表）

> 代码地图的灵魂

```ts
interface Relation {
  id: string;

  fromSymbolId: string;
  toSymbolId?: string;

  type: 'IMPORTS' | 'CALLS' | 'IMPLEMENTS' | 'EXTENDS' | 'USES' | 'REFERENCES';

  confidence: number; // 0~1（静态分析置信度）
}
```

示例：

```json
{
  "fromSymbolId": "auth.verifyToken",
  "toSymbolId": "jwt.verify",
  "type": "CALLS",
  "confidence": 0.85
}
```

---

### 4. 跨仓库关系

#### 4.1 典型场景

- API Client → Service
- SDK → Backend
- Shared lib → Consumer

#### 4.2 设计方式

**不要强制跨 repo 解析 import** → 使用 **软关联 + 语义命中**

```ts
interface CrossRepoLink {
  fromRepoId: string;
  toRepoId: string;

  via: 'http' | 'rpc' | 'sdk' | 'event';

  evidence: string; // openapi / fetch url
}
```

---

### 5. RAG 专用索引结构

#### 5.1 Embedding 表

```ts
interface Embedding {
  symbolId: string;
  vector: number[]; // embedding
  contentHash: string;
}
```

#### 5.2 RAG 检索元数据

```ts
interface RagMeta {
  symbolId: string;

  repoName: string;
  filePath: string;
  symbolKind: string;

  importanceScore: number; // exported > private
}
```

---

### 6. 数据库实现建议

#### 6.1 推荐组合（生产级）

```text
PostgreSQL
├─ symbols
├─ files
├─ repos
├─ relations
├─ embeddings (pgvector)
```

#### 6.2 Symbol 表示例

```sql
CREATE TABLE symbols (
  id TEXT PRIMARY KEY,
  repo_id TEXT,
  file_id TEXT,
  name TEXT,
  qualified_name TEXT,
  kind TEXT,
  code_chunk TEXT
);
```

---

### 7. 设计原则总结

> **代码地图 ≠ 文件树**
> **代码地图 = Symbol + Relation + Repo Context**

**三条铁律**：

1. **Symbol 是最小认知单元**
2. **Relation 是地图价值来源**
3. **Repo 是隔离边界**

---

## 第一部分：Qdrant 向量数据库设计

### 1. 设计原则

Qdrant **只做一件事**：**高质量语义召回（Semantic Recall）**

**不负责**：

- 依赖图遍历
- 复杂结构查询
- 业务状态管理

因此 Schema 要 **扁平、稳定、可过滤**。

---

### 2. Collection 设计

#### 2.1 Collection 名称

```text
code_symbols
```

**推荐方案**：全局一个 Collection，用 payload 区分 workspace

> ❌ 一个 Workspace 一个 Collection 会导致管理复杂、Schema 不一致

#### 2.2 向量配置

```json
{
  "vectors": {
    "code": {
      "size": 3072,
      "distance": "Cosine"
    }
  }
}
```

- 使用 `text-embedding-3-large`（3072 维）
- 单向量即可（多向量是进阶玩法）

---

### 3. Point 结构设计

#### 3.1 Point ID

```text
symbol:{symbolId}
```

示例：

```text
symbol:auth-service:src/token.ts:verifyToken
```

优点：

- 全局唯一
- 可直接映射到图系统
- Debug 友好

#### 3.2 Payload Schema

```ts
interface SymbolPayload {
  // 作用域
  workspace_id: string;
  repo_id: string;
  repo_name: string;

  // 代码定位
  file_path: string;
  language: string;

  // Symbol 信息
  symbol_id: string;
  symbol_name: string;
  symbol_kind: 'function' | 'class' | 'method' | 'interface' | 'type';
  exported: boolean;
  visibility: 'public' | 'private' | 'protected';

  // 代码内容
  code: string;
  signature?: string;

  // 权重与排序
  importance: number; // 0~1，用于 rerank

  // 索引控制
  commit: string;
  indexed_at: number;
}
```

---

### 4. Payload Index 配置

**必须设置以下索引**（性能关键）：

```ts
const indexes = [
  { field_name: 'workspace_id', field_schema: 'keyword' },
  { field_name: 'repo_id', field_schema: 'keyword' },
  { field_name: 'symbol_kind', field_schema: 'keyword' },
  { field_name: 'exported', field_schema: 'bool' },
  { field_name: 'language', field_schema: 'keyword' }
];

for (const index of indexes) {
  await client.createPayloadIndex('code_symbols', index);
}
```

> 这 5 个索引是**必需项**，否则多 repo 查询会明显变慢

---

### 5. Embedding 内容拼装规范

#### 5.1 推荐输入结构

```text
[Symbol Signature]
[Code Body]
[Doc Comment Summary]
```

示例代码：

```ts
/**
 * Verify JWT token and return user info
 */
export function verifyToken(token: string): User {
  // ...
}
```

拼装后：

```text
function verifyToken(token: string): User
export function verifyToken(token: string): User { ... }
Verify JWT token and return user info
```

#### 5.2 排除内容

- TODO / FIXME
- 日志字符串
- 单行无意义注释
- README 内容

---

### 6. 增量更新策略

#### 6.1 更新判断

基于 `symbol_id + commit`：

- commit 未变 → 不更新
- symbol hash 变化 → upsert

#### 6.2 删除策略

Repo 删除时：

```ts
await client.delete('code_symbols', {
  filter: {
    must: [{ key: 'repo_id', match: { value: repoId } }]
  }
});
```

---

### 7. 查询设计

#### 7.1 基础向量查询

```ts
await client.search('code_symbols', {
  vector: queryEmbedding,
  limit: 10,
  filter: {
    must: [{ key: 'workspace_id', match: { value: workspaceId } }]
  }
});
```

#### 7.2 限定 Repo 查询

```ts
filter: {
  must: [
    { key: 'workspace_id', match: { value: workspaceId } },
    { key: 'repo_id', match: { any: repoIds } }
  ];
}
```

#### 7.3 只查公共 API

```ts
filter: {
  must: [{ key: 'exported', match: { value: true } }];
}
```

---

### 8. 进阶设计（可选）

#### 8.1 多向量（Code / Doc 分离）

```json
{
  "vectors": {
    "code": { "size": 3072, "distance": "Cosine" },
    "doc": { "size": 3072, "distance": "Cosine" }
  }
}
```

#### 8.2 稀疏向量（Hybrid Search）

```json
{
  "sparse_vectors": {
    "bm25": {}
  }
}
```

---

## 第二部分：Graph 图系统设计

### 1. 设计原则

图系统**只解决"结构关系"**，不解决"语义相关性"

**负责回答**：

- 谁调用了谁
- 谁依赖了谁
- 一个 Symbol 的上下游
- Repo / File / Symbol 之间的结构关系

**不负责**：

- 相似度搜索
- 排序
- 语言理解

---

### 2. 抽象模型

#### 2.1 节点（Node）

**不单独存 Node 表**，Node = 一个字符串 ID，由上层定义

**统一 ID 规范**：

```text
<workspace>/<repo>/<file>#<symbol>
```

示例：

```text
ws1/auth-service/src/token.ts#verifyToken
ws1/shared-lib/src/jwt.ts#verify
```

优点：

- 全局唯一
- 天然支持多 workspace
- Qdrant / Graph 共用 ID

#### 2.2 边（Edge）

```ts
interface Edge {
  from: string; // node id
  to: string; // node id
  type: EdgeType;
  confidence: number; // 0~1
}

type EdgeType =
  | 'IMPORTS' // 文件 → 文件
  | 'CALLS' // 函数 → 函数
  | 'IMPLEMENTS' // class → interface
  | 'EXTENDS' // class → class
  | 'USES' // 弱依赖
  | 'EXPOSES'; // repo → api
```

> **不要超过 6 种类型**，图一复杂，查询和维护都会崩

---

### 3. 存储实现

#### 3.1 总体架构

```text
内存 Graph（查询）
     ↑
文件存储（持久化）
```

#### 3.2 内存图结构

```ts
class Graph {
  out = new Map<string, Map<EdgeType, Set<string>>>();
  in = new Map<string, Map<EdgeType, Set<string>>>();
}
```

特点：O(1) 查询，非常适合 API 实时请求

#### 3.3 持久化结构

**Key 设计**：

```text
edge:<from>:<type>  -> [to1, to2, ...]
redge:<to>:<type>   -> [from1, from2, ...]
```

示例：

```text
edge:ws1/auth/...#verifyToken:CALLS
```

Value：

```json
["ws1/shared/...#verify", "ws1/log/...#info"]
```

**写入示例**：

```ts
await db.put(`edge:${from}:${type}`, JSON.stringify([...tos]));
```

**启动加载**：

```ts
for await (const [key, value] of db.iterator()) {
  // 重建内存 Graph
}
```

---

### 4. API 设计

#### 4.1 查询直接依赖（OUT）

```ts
function getDependencies(symbolId: string, type?: EdgeType): DependencyResult;
```

返回：

```json
{
  "from": "ws1/auth/...#verifyToken",
  "edges": [{ "to": "ws1/shared/...#verify", "type": "CALLS" }]
}
```

#### 4.2 查询反向依赖（IN）

```ts
function getReverseDependencies(symbolId: string, type?: EdgeType): DependencyResult;
```

#### 4.3 多跳遍历（BFS）

```ts
function traverse(start: string, depth: number, type?: EdgeType): TraverseResult;
```

伪代码：

```ts
queue = [start];
visited = new Set();

if (level < depth) {
  for (node of queue) {
    neighbors = out[node][type];
  }
}
```

---

### 5. 索引构建

#### 5.1 AST → Edge 生成

| 分析阶段         | 生成的 Edge |
| ---------------- | ----------- |
| import 语句      | IMPORTS     |
| 函数调用         | CALLS       |
| class implements | IMPLEMENTS  |
| class extends    | EXTENDS     |

#### 5.2 示例（CALLS）

```ts
function verifyToken() {
  jwt.verify();
}
```

生成：

```text
verifyToken ──CALLS──▶ jwt.verify
confidence = 0.8
```

#### 5.3 置信度设计

| 场景         | confidence |
| ------------ | ---------- |
| 静态 import  | 1.0        |
| 明确函数调用 | 0.8        |
| 动态调用     | 0.4        |

> 查询时可以过滤低置信度

---

### 6. 增量更新策略

#### 6.1 文件变更

```text
git diff
 ├─ 删除文件
 │   └─ 删除所有相关 edge
 └─ 修改文件
     ├─ 删除旧 edge
     └─ 写入新 edge
```

> **不要做"边 diff"**，直接删 + 重建该文件的边，最稳

#### 6.2 Repo 删除

```ts
// 删除 from 包含 repoId 的边
// 删除 to 包含 repoId 的边
```

---

## 第三部分：系统协作

### 1. Qdrant 与 Graph 的边界

| 能力        | Qdrant | Graph |
| ----------- | ------ | ----- |
| 语义相似    | ✅     | ❌    |
| 结构关系    | ❌     | ✅    |
| 过滤 repo   | ✅     | ✅    |
| 增量更新    | ✅     | ✅    |
| RAG Context | 主     | 辅    |

### 2. 联合查询流程

```text
User Query
    ↓
Qdrant (Semantic Recall)
    ↓
Graph (Structural Expansion)
    ↓
Context Builder
    ↓
LLM
```

#### 示例

> 查询："token 是在哪里校验的？"

1. **Qdrant 命中**：`verifyToken`
2. **Graph 扩展**：`verifyToken CALLS jwt.verify`
3. **Context**：verifyToken + jwt.verify

### 3. 为什么不反过来（图 → 向量）？

❌ 会引入大量无关节点

### 4. Qdrant 返回什么？

```json
{
  "symbol_id": "auth.verifyToken",
  "code": "...",
  "score": 0.87
}
```

### 5. Graph 用 symbol_id 做什么？

- 查 CALLS
- 查 IMPORTS
- 扩展上下文

> **Qdrant 不知道"关系"，Graph 不知道"语义"**
